#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Operation:
  MIN = 0
  MAX = 1
  FIRST = 2
  LAST = 3
  UNIQUE_COUNT = 4
  APPROX_UNIQUE_COUNT = 5
  COUNT = 6
  SUM = 7
  AVERAGE = 8
  VARIANCE = 9
  SKEW = 10
  KURTOSIS = 11
  APPROX_PERCENTILE = 12
  LAST_K = 13
  FIRST_K = 14
  TOP_K = 15
  BOTTOM_K = 16
  HISTOGRAM = 17

  _VALUES_TO_NAMES = {
    0: "MIN",
    1: "MAX",
    2: "FIRST",
    3: "LAST",
    4: "UNIQUE_COUNT",
    5: "APPROX_UNIQUE_COUNT",
    6: "COUNT",
    7: "SUM",
    8: "AVERAGE",
    9: "VARIANCE",
    10: "SKEW",
    11: "KURTOSIS",
    12: "APPROX_PERCENTILE",
    13: "LAST_K",
    14: "FIRST_K",
    15: "TOP_K",
    16: "BOTTOM_K",
    17: "HISTOGRAM",
  }

  _NAMES_TO_VALUES = {
    "MIN": 0,
    "MAX": 1,
    "FIRST": 2,
    "LAST": 3,
    "UNIQUE_COUNT": 4,
    "APPROX_UNIQUE_COUNT": 5,
    "COUNT": 6,
    "SUM": 7,
    "AVERAGE": 8,
    "VARIANCE": 9,
    "SKEW": 10,
    "KURTOSIS": 11,
    "APPROX_PERCENTILE": 12,
    "LAST_K": 13,
    "FIRST_K": 14,
    "TOP_K": 15,
    "BOTTOM_K": 16,
    "HISTOGRAM": 17,
  }

class TimeUnit:
  HOURS = 0
  DAYS = 1

  _VALUES_TO_NAMES = {
    0: "HOURS",
    1: "DAYS",
  }

  _NAMES_TO_VALUES = {
    "HOURS": 0,
    "DAYS": 1,
  }

class Accuracy:
  TEMPORAL = 0
  SNAPSHOT = 1

  _VALUES_TO_NAMES = {
    0: "TEMPORAL",
    1: "SNAPSHOT",
  }

  _NAMES_TO_VALUES = {
    "TEMPORAL": 0,
    "SNAPSHOT": 1,
  }


class Query:
  """
  Attributes:
   - selects
   - wheres
   - startPartition
   - endPartition
   - timeColumn
   - setups
   - mutationTimeColumn
   - reversalColumn
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'selects', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'wheres', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'startPartition', None, None, ), # 3
    (4, TType.STRING, 'endPartition', None, None, ), # 4
    (5, TType.STRING, 'timeColumn', None, None, ), # 5
    (6, TType.LIST, 'setups', (TType.STRING,None), [
    ], ), # 6
    (7, TType.STRING, 'mutationTimeColumn', None, None, ), # 7
    (8, TType.STRING, 'reversalColumn', None, None, ), # 8
  )

  def __init__(self, selects=None, wheres=None, startPartition=None, endPartition=None, timeColumn=None, setups=thrift_spec[6][4], mutationTimeColumn=None, reversalColumn=None,):
    self.selects = selects
    self.wheres = wheres
    self.startPartition = startPartition
    self.endPartition = endPartition
    self.timeColumn = timeColumn
    if setups is self.thrift_spec[6][4]:
      setups = [
    ]
    self.setups = setups
    self.mutationTimeColumn = mutationTimeColumn
    self.reversalColumn = reversalColumn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.selects = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString()
            _val6 = iprot.readString()
            self.selects[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.wheres = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.wheres.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startPartition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endPartition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.timeColumn = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.setups = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readString()
            self.setups.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.mutationTimeColumn = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.reversalColumn = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Query')
    if self.selects is not None:
      oprot.writeFieldBegin('selects', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.selects))
      for kiter19,viter20 in self.selects.items():
        oprot.writeString(kiter19)
        oprot.writeString(viter20)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.wheres is not None:
      oprot.writeFieldBegin('wheres', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.wheres))
      for iter21 in self.wheres:
        oprot.writeString(iter21)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.startPartition is not None:
      oprot.writeFieldBegin('startPartition', TType.STRING, 3)
      oprot.writeString(self.startPartition)
      oprot.writeFieldEnd()
    if self.endPartition is not None:
      oprot.writeFieldBegin('endPartition', TType.STRING, 4)
      oprot.writeString(self.endPartition)
      oprot.writeFieldEnd()
    if self.timeColumn is not None:
      oprot.writeFieldBegin('timeColumn', TType.STRING, 5)
      oprot.writeString(self.timeColumn)
      oprot.writeFieldEnd()
    if self.setups is not None:
      oprot.writeFieldBegin('setups', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.setups))
      for iter22 in self.setups:
        oprot.writeString(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mutationTimeColumn is not None:
      oprot.writeFieldBegin('mutationTimeColumn', TType.STRING, 7)
      oprot.writeString(self.mutationTimeColumn)
      oprot.writeFieldEnd()
    if self.reversalColumn is not None:
      oprot.writeFieldBegin('reversalColumn', TType.STRING, 8)
      oprot.writeString(self.reversalColumn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.selects)
    value = (value * 31) ^ hash(self.wheres)
    value = (value * 31) ^ hash(self.startPartition)
    value = (value * 31) ^ hash(self.endPartition)
    value = (value * 31) ^ hash(self.timeColumn)
    value = (value * 31) ^ hash(self.setups)
    value = (value * 31) ^ hash(self.mutationTimeColumn)
    value = (value * 31) ^ hash(self.reversalColumn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StagingQuery:
  """
  Attributes:
   - metaData
   - query
   - startPartition
   - setups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'metaData', (MetaData, MetaData.thrift_spec), None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
    (3, TType.STRING, 'startPartition', None, None, ), # 3
    (4, TType.LIST, 'setups', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, metaData=None, query=None, startPartition=None, setups=None,):
    self.metaData = metaData
    self.query = query
    self.startPartition = startPartition
    self.setups = setups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.metaData = MetaData()
          self.metaData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startPartition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.setups = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString()
            self.setups.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StagingQuery')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
      self.metaData.write(oprot)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.startPartition is not None:
      oprot.writeFieldBegin('startPartition', TType.STRING, 3)
      oprot.writeString(self.startPartition)
      oprot.writeFieldEnd()
    if self.setups is not None:
      oprot.writeFieldBegin('setups', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.setups))
      for iter29 in self.setups:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metaData)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.startPartition)
    value = (value * 31) ^ hash(self.setups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventSource:
  """
  Attributes:
   - table
   - topic
   - query
   - isCumulative
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'table', None, None, ), # 1
    (2, TType.STRING, 'topic', None, None, ), # 2
    (3, TType.STRUCT, 'query', (Query, Query.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'isCumulative', None, None, ), # 4
  )

  def __init__(self, table=None, topic=None, query=None, isCumulative=None,):
    self.table = table
    self.topic = topic
    self.query = query
    self.isCumulative = isCumulative

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.table = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.topic = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.query = Query()
          self.query.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isCumulative = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventSource')
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRING, 1)
      oprot.writeString(self.table)
      oprot.writeFieldEnd()
    if self.topic is not None:
      oprot.writeFieldBegin('topic', TType.STRING, 2)
      oprot.writeString(self.topic)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRUCT, 3)
      self.query.write(oprot)
      oprot.writeFieldEnd()
    if self.isCumulative is not None:
      oprot.writeFieldBegin('isCumulative', TType.BOOL, 4)
      oprot.writeBool(self.isCumulative)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.table)
    value = (value * 31) ^ hash(self.topic)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.isCumulative)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EntitySource:
  """
  Attributes:
   - snapshotTable
   - mutationTable
   - mutationTopic
   - query
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snapshotTable', None, None, ), # 1
    (2, TType.STRING, 'mutationTable', None, None, ), # 2
    (3, TType.STRING, 'mutationTopic', None, None, ), # 3
    (4, TType.STRUCT, 'query', (Query, Query.thrift_spec), None, ), # 4
  )

  def __init__(self, snapshotTable=None, mutationTable=None, mutationTopic=None, query=None,):
    self.snapshotTable = snapshotTable
    self.mutationTable = mutationTable
    self.mutationTopic = mutationTopic
    self.query = query

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snapshotTable = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mutationTable = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mutationTopic = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.query = Query()
          self.query.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntitySource')
    if self.snapshotTable is not None:
      oprot.writeFieldBegin('snapshotTable', TType.STRING, 1)
      oprot.writeString(self.snapshotTable)
      oprot.writeFieldEnd()
    if self.mutationTable is not None:
      oprot.writeFieldBegin('mutationTable', TType.STRING, 2)
      oprot.writeString(self.mutationTable)
      oprot.writeFieldEnd()
    if self.mutationTopic is not None:
      oprot.writeFieldBegin('mutationTopic', TType.STRING, 3)
      oprot.writeString(self.mutationTopic)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRUCT, 4)
      self.query.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapshotTable)
    value = (value * 31) ^ hash(self.mutationTable)
    value = (value * 31) ^ hash(self.mutationTopic)
    value = (value * 31) ^ hash(self.query)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Source:
  """
  Attributes:
   - events
   - entities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'events', (EventSource, EventSource.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'entities', (EntitySource, EntitySource.thrift_spec), None, ), # 2
  )

  def __init__(self, events=None, entities=None,):
    self.events = events
    self.entities = entities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.events = EventSource()
          self.events.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entities = EntitySource()
          self.entities.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Source')
    if self.events is not None:
      oprot.writeFieldBegin('events', TType.STRUCT, 1)
      self.events.write(oprot)
      oprot.writeFieldEnd()
    if self.entities is not None:
      oprot.writeFieldBegin('entities', TType.STRUCT, 2)
      self.entities.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.events)
    value = (value * 31) ^ hash(self.entities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Window:
  """
  Attributes:
   - length
   - timeUnit
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'length', None, None, ), # 1
    (2, TType.I32, 'timeUnit', None, None, ), # 2
  )

  def __init__(self, length=None, timeUnit=None,):
    self.length = length
    self.timeUnit = timeUnit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.length = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.timeUnit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Window')
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I32, 1)
      oprot.writeI32(self.length)
      oprot.writeFieldEnd()
    if self.timeUnit is not None:
      oprot.writeFieldBegin('timeUnit', TType.I32, 2)
      oprot.writeI32(self.timeUnit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.length)
    value = (value * 31) ^ hash(self.timeUnit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Aggregation:
  """
  Attributes:
   - inputColumn
   - operation
   - argMap
   - windows
   - buckets
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputColumn', None, None, ), # 1
    (2, TType.I32, 'operation', None, None, ), # 2
    (3, TType.MAP, 'argMap', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'windows', (TType.STRUCT,(Window, Window.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'buckets', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, inputColumn=None, operation=None, argMap=None, windows=None, buckets=None,):
    self.inputColumn = inputColumn
    self.operation = operation
    self.argMap = argMap
    self.windows = windows
    self.buckets = buckets

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputColumn = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operation = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.argMap = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin()
          for _i34 in xrange(_size30):
            _key35 = iprot.readString()
            _val36 = iprot.readString()
            self.argMap[_key35] = _val36
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.windows = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = Window()
            _elem42.read(iprot)
            self.windows.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.buckets = []
          (_etype46, _size43) = iprot.readListBegin()
          for _i47 in xrange(_size43):
            _elem48 = iprot.readString()
            self.buckets.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Aggregation')
    if self.inputColumn is not None:
      oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
      oprot.writeString(self.inputColumn)
      oprot.writeFieldEnd()
    if self.operation is not None:
      oprot.writeFieldBegin('operation', TType.I32, 2)
      oprot.writeI32(self.operation)
      oprot.writeFieldEnd()
    if self.argMap is not None:
      oprot.writeFieldBegin('argMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
      for kiter49,viter50 in self.argMap.items():
        oprot.writeString(kiter49)
        oprot.writeString(viter50)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.windows is not None:
      oprot.writeFieldBegin('windows', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.windows))
      for iter51 in self.windows:
        iter51.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.buckets is not None:
      oprot.writeFieldBegin('buckets', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.buckets))
      for iter52 in self.buckets:
        oprot.writeString(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputColumn)
    value = (value * 31) ^ hash(self.operation)
    value = (value * 31) ^ hash(self.argMap)
    value = (value * 31) ^ hash(self.windows)
    value = (value * 31) ^ hash(self.buckets)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggregationPart:
  """
  Attributes:
   - inputColumn
   - operation
   - argMap
   - window
   - bucket
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inputColumn', None, None, ), # 1
    (2, TType.I32, 'operation', None, None, ), # 2
    (3, TType.MAP, 'argMap', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'window', (Window, Window.thrift_spec), None, ), # 4
    (5, TType.STRING, 'bucket', None, None, ), # 5
  )

  def __init__(self, inputColumn=None, operation=None, argMap=None, window=None, bucket=None,):
    self.inputColumn = inputColumn
    self.operation = operation
    self.argMap = argMap
    self.window = window
    self.bucket = bucket

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inputColumn = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operation = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.argMap = {}
          (_ktype54, _vtype55, _size53 ) = iprot.readMapBegin()
          for _i57 in xrange(_size53):
            _key58 = iprot.readString()
            _val59 = iprot.readString()
            self.argMap[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.window = Window()
          self.window.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.bucket = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggregationPart')
    if self.inputColumn is not None:
      oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
      oprot.writeString(self.inputColumn)
      oprot.writeFieldEnd()
    if self.operation is not None:
      oprot.writeFieldBegin('operation', TType.I32, 2)
      oprot.writeI32(self.operation)
      oprot.writeFieldEnd()
    if self.argMap is not None:
      oprot.writeFieldBegin('argMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
      for kiter60,viter61 in self.argMap.items():
        oprot.writeString(kiter60)
        oprot.writeString(viter61)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.window is not None:
      oprot.writeFieldBegin('window', TType.STRUCT, 4)
      self.window.write(oprot)
      oprot.writeFieldEnd()
    if self.bucket is not None:
      oprot.writeFieldBegin('bucket', TType.STRING, 5)
      oprot.writeString(self.bucket)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inputColumn)
    value = (value * 31) ^ hash(self.operation)
    value = (value * 31) ^ hash(self.argMap)
    value = (value * 31) ^ hash(self.window)
    value = (value * 31) ^ hash(self.bucket)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetaData:
  """
  Attributes:
   - name
   - online
   - production
   - customJson
   - dependencies
   - tableProperties
   - outputNamespace
   - team
   - modeToEnvMap
   - consistencyCheck
   - samplePercent
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'online', None, None, ), # 2
    (3, TType.BOOL, 'production', None, None, ), # 3
    (4, TType.STRING, 'customJson', None, None, ), # 4
    (5, TType.LIST, 'dependencies', (TType.STRING,None), None, ), # 5
    (6, TType.MAP, 'tableProperties', (TType.STRING,None,TType.STRING,None), None, ), # 6
    (7, TType.STRING, 'outputNamespace', None, None, ), # 7
    (8, TType.STRING, 'team', None, None, ), # 8
    (9, TType.MAP, 'modeToEnvMap', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 9
    (10, TType.BOOL, 'consistencyCheck', None, None, ), # 10
    (11, TType.DOUBLE, 'samplePercent', None, None, ), # 11
  )

  def __init__(self, name=None, online=None, production=None, customJson=None, dependencies=None, tableProperties=None, outputNamespace=None, team=None, modeToEnvMap=None, consistencyCheck=None, samplePercent=None,):
    self.name = name
    self.online = online
    self.production = production
    self.customJson = customJson
    self.dependencies = dependencies
    self.tableProperties = tableProperties
    self.outputNamespace = outputNamespace
    self.team = team
    self.modeToEnvMap = modeToEnvMap
    self.consistencyCheck = consistencyCheck
    self.samplePercent = samplePercent

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.online = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.production = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.customJson = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.dependencies = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString()
            self.dependencies.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.tableProperties = {}
          (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin()
          for _i72 in xrange(_size68):
            _key73 = iprot.readString()
            _val74 = iprot.readString()
            self.tableProperties[_key73] = _val74
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.outputNamespace = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.team = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.modeToEnvMap = {}
          (_ktype76, _vtype77, _size75 ) = iprot.readMapBegin()
          for _i79 in xrange(_size75):
            _key80 = iprot.readString()
            _val81 = {}
            (_ktype83, _vtype84, _size82 ) = iprot.readMapBegin()
            for _i86 in xrange(_size82):
              _key87 = iprot.readString()
              _val88 = iprot.readString()
              _val81[_key87] = _val88
            iprot.readMapEnd()
            self.modeToEnvMap[_key80] = _val81
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.consistencyCheck = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.DOUBLE:
          self.samplePercent = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetaData')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.online is not None:
      oprot.writeFieldBegin('online', TType.BOOL, 2)
      oprot.writeBool(self.online)
      oprot.writeFieldEnd()
    if self.production is not None:
      oprot.writeFieldBegin('production', TType.BOOL, 3)
      oprot.writeBool(self.production)
      oprot.writeFieldEnd()
    if self.customJson is not None:
      oprot.writeFieldBegin('customJson', TType.STRING, 4)
      oprot.writeString(self.customJson)
      oprot.writeFieldEnd()
    if self.dependencies is not None:
      oprot.writeFieldBegin('dependencies', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.dependencies))
      for iter89 in self.dependencies:
        oprot.writeString(iter89)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tableProperties is not None:
      oprot.writeFieldBegin('tableProperties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
      for kiter90,viter91 in self.tableProperties.items():
        oprot.writeString(kiter90)
        oprot.writeString(viter91)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.outputNamespace is not None:
      oprot.writeFieldBegin('outputNamespace', TType.STRING, 7)
      oprot.writeString(self.outputNamespace)
      oprot.writeFieldEnd()
    if self.team is not None:
      oprot.writeFieldBegin('team', TType.STRING, 8)
      oprot.writeString(self.team)
      oprot.writeFieldEnd()
    if self.modeToEnvMap is not None:
      oprot.writeFieldBegin('modeToEnvMap', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeToEnvMap))
      for kiter92,viter93 in self.modeToEnvMap.items():
        oprot.writeString(kiter92)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter93))
        for kiter94,viter95 in viter93.items():
          oprot.writeString(kiter94)
          oprot.writeString(viter95)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.consistencyCheck is not None:
      oprot.writeFieldBegin('consistencyCheck', TType.BOOL, 10)
      oprot.writeBool(self.consistencyCheck)
      oprot.writeFieldEnd()
    if self.samplePercent is not None:
      oprot.writeFieldBegin('samplePercent', TType.DOUBLE, 11)
      oprot.writeDouble(self.samplePercent)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.online)
    value = (value * 31) ^ hash(self.production)
    value = (value * 31) ^ hash(self.customJson)
    value = (value * 31) ^ hash(self.dependencies)
    value = (value * 31) ^ hash(self.tableProperties)
    value = (value * 31) ^ hash(self.outputNamespace)
    value = (value * 31) ^ hash(self.team)
    value = (value * 31) ^ hash(self.modeToEnvMap)
    value = (value * 31) ^ hash(self.consistencyCheck)
    value = (value * 31) ^ hash(self.samplePercent)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GroupBy:
  """
  Attributes:
   - metaData
   - sources
   - keyColumns
   - aggregations
   - accuracy
   - backfillStartDate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'metaData', (MetaData, MetaData.thrift_spec), None, ), # 1
    (2, TType.LIST, 'sources', (TType.STRUCT,(Source, Source.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'keyColumns', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'aggregations', (TType.STRUCT,(Aggregation, Aggregation.thrift_spec)), None, ), # 4
    (5, TType.I32, 'accuracy', None, None, ), # 5
    (6, TType.STRING, 'backfillStartDate', None, None, ), # 6
  )

  def __init__(self, metaData=None, sources=None, keyColumns=None, aggregations=None, accuracy=None, backfillStartDate=None,):
    self.metaData = metaData
    self.sources = sources
    self.keyColumns = keyColumns
    self.aggregations = aggregations
    self.accuracy = accuracy
    self.backfillStartDate = backfillStartDate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.metaData = MetaData()
          self.metaData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sources = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = Source()
            _elem101.read(iprot)
            self.sources.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.keyColumns = []
          (_etype105, _size102) = iprot.readListBegin()
          for _i106 in xrange(_size102):
            _elem107 = iprot.readString()
            self.keyColumns.append(_elem107)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.aggregations = []
          (_etype111, _size108) = iprot.readListBegin()
          for _i112 in xrange(_size108):
            _elem113 = Aggregation()
            _elem113.read(iprot)
            self.aggregations.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.accuracy = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.backfillStartDate = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GroupBy')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
      self.metaData.write(oprot)
      oprot.writeFieldEnd()
    if self.sources is not None:
      oprot.writeFieldBegin('sources', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sources))
      for iter114 in self.sources:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.keyColumns is not None:
      oprot.writeFieldBegin('keyColumns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.keyColumns))
      for iter115 in self.keyColumns:
        oprot.writeString(iter115)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aggregations is not None:
      oprot.writeFieldBegin('aggregations', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.aggregations))
      for iter116 in self.aggregations:
        iter116.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.accuracy is not None:
      oprot.writeFieldBegin('accuracy', TType.I32, 5)
      oprot.writeI32(self.accuracy)
      oprot.writeFieldEnd()
    if self.backfillStartDate is not None:
      oprot.writeFieldBegin('backfillStartDate', TType.STRING, 6)
      oprot.writeString(self.backfillStartDate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metaData)
    value = (value * 31) ^ hash(self.sources)
    value = (value * 31) ^ hash(self.keyColumns)
    value = (value * 31) ^ hash(self.aggregations)
    value = (value * 31) ^ hash(self.accuracy)
    value = (value * 31) ^ hash(self.backfillStartDate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AggregationSelector:
  """
  Attributes:
   - name
   - windows
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.LIST, 'windows', (TType.STRUCT,(Window, Window.thrift_spec)), None, ), # 2
  )

  def __init__(self, name=None, windows=None,):
    self.name = name
    self.windows = windows

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.windows = []
          (_etype120, _size117) = iprot.readListBegin()
          for _i121 in xrange(_size117):
            _elem122 = Window()
            _elem122.read(iprot)
            self.windows.append(_elem122)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AggregationSelector')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.windows is not None:
      oprot.writeFieldBegin('windows', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.windows))
      for iter123 in self.windows:
        iter123.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.windows)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JoinPart:
  """
  Attributes:
   - groupBy
   - keyMapping
   - selectors
   - prefix
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'groupBy', (GroupBy, GroupBy.thrift_spec), None, ), # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'selectors', (TType.STRUCT,(AggregationSelector, AggregationSelector.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'prefix', None, None, ), # 4
  )

  def __init__(self, groupBy=None, keyMapping=None, selectors=None, prefix=None,):
    self.groupBy = groupBy
    self.keyMapping = keyMapping
    self.selectors = selectors
    self.prefix = prefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.groupBy = GroupBy()
          self.groupBy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keyMapping = {}
          (_ktype125, _vtype126, _size124 ) = iprot.readMapBegin()
          for _i128 in xrange(_size124):
            _key129 = iprot.readString()
            _val130 = iprot.readString()
            self.keyMapping[_key129] = _val130
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.selectors = []
          (_etype134, _size131) = iprot.readListBegin()
          for _i135 in xrange(_size131):
            _elem136 = AggregationSelector()
            _elem136.read(iprot)
            self.selectors.append(_elem136)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.prefix = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JoinPart')
    if self.groupBy is not None:
      oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
      self.groupBy.write(oprot)
      oprot.writeFieldEnd()
    if self.keyMapping is not None:
      oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
      for kiter137,viter138 in self.keyMapping.items():
        oprot.writeString(kiter137)
        oprot.writeString(viter138)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.selectors is not None:
      oprot.writeFieldBegin('selectors', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.selectors))
      for iter139 in self.selectors:
        iter139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prefix is not None:
      oprot.writeFieldBegin('prefix', TType.STRING, 4)
      oprot.writeString(self.prefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.groupBy)
    value = (value * 31) ^ hash(self.keyMapping)
    value = (value * 31) ^ hash(self.selectors)
    value = (value * 31) ^ hash(self.prefix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Join:
  """
  Attributes:
   - metaData
   - left
   - joinParts
   - skewKeys
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'metaData', (MetaData, MetaData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'left', (Source, Source.thrift_spec), None, ), # 2
    (3, TType.LIST, 'joinParts', (TType.STRUCT,(JoinPart, JoinPart.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'skewKeys', (TType.STRING,None,TType.LIST,(TType.STRING,None)), None, ), # 4
  )

  def __init__(self, metaData=None, left=None, joinParts=None, skewKeys=None,):
    self.metaData = metaData
    self.left = left
    self.joinParts = joinParts
    self.skewKeys = skewKeys

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.metaData = MetaData()
          self.metaData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.left = Source()
          self.left.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.joinParts = []
          (_etype143, _size140) = iprot.readListBegin()
          for _i144 in xrange(_size140):
            _elem145 = JoinPart()
            _elem145.read(iprot)
            self.joinParts.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.skewKeys = {}
          (_ktype147, _vtype148, _size146 ) = iprot.readMapBegin()
          for _i150 in xrange(_size146):
            _key151 = iprot.readString()
            _val152 = []
            (_etype156, _size153) = iprot.readListBegin()
            for _i157 in xrange(_size153):
              _elem158 = iprot.readString()
              _val152.append(_elem158)
            iprot.readListEnd()
            self.skewKeys[_key151] = _val152
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Join')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
      self.metaData.write(oprot)
      oprot.writeFieldEnd()
    if self.left is not None:
      oprot.writeFieldBegin('left', TType.STRUCT, 2)
      self.left.write(oprot)
      oprot.writeFieldEnd()
    if self.joinParts is not None:
      oprot.writeFieldBegin('joinParts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.joinParts))
      for iter159 in self.joinParts:
        iter159.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.skewKeys is not None:
      oprot.writeFieldBegin('skewKeys', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
      for kiter160,viter161 in self.skewKeys.items():
        oprot.writeString(kiter160)
        oprot.writeListBegin(TType.STRING, len(viter161))
        for iter162 in viter161:
          oprot.writeString(iter162)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.metaData)
    value = (value * 31) ^ hash(self.left)
    value = (value * 31) ^ hash(self.joinParts)
    value = (value * 31) ^ hash(self.skewKeys)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GroupByServingInfo:
  """
  Attributes:
   - groupBy
   - inputAvroSchema
   - selectedAvroSchema
   - keyAvroSchema
   - batchEndDate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'groupBy', (GroupBy, GroupBy.thrift_spec), None, ), # 1
    (2, TType.STRING, 'inputAvroSchema', None, None, ), # 2
    (3, TType.STRING, 'selectedAvroSchema', None, None, ), # 3
    (4, TType.STRING, 'keyAvroSchema', None, None, ), # 4
    (5, TType.STRING, 'batchEndDate', None, None, ), # 5
  )

  def __init__(self, groupBy=None, inputAvroSchema=None, selectedAvroSchema=None, keyAvroSchema=None, batchEndDate=None,):
    self.groupBy = groupBy
    self.inputAvroSchema = inputAvroSchema
    self.selectedAvroSchema = selectedAvroSchema
    self.keyAvroSchema = keyAvroSchema
    self.batchEndDate = batchEndDate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.groupBy = GroupBy()
          self.groupBy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inputAvroSchema = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.selectedAvroSchema = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.keyAvroSchema = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.batchEndDate = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GroupByServingInfo')
    if self.groupBy is not None:
      oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
      self.groupBy.write(oprot)
      oprot.writeFieldEnd()
    if self.inputAvroSchema is not None:
      oprot.writeFieldBegin('inputAvroSchema', TType.STRING, 2)
      oprot.writeString(self.inputAvroSchema)
      oprot.writeFieldEnd()
    if self.selectedAvroSchema is not None:
      oprot.writeFieldBegin('selectedAvroSchema', TType.STRING, 3)
      oprot.writeString(self.selectedAvroSchema)
      oprot.writeFieldEnd()
    if self.keyAvroSchema is not None:
      oprot.writeFieldBegin('keyAvroSchema', TType.STRING, 4)
      oprot.writeString(self.keyAvroSchema)
      oprot.writeFieldEnd()
    if self.batchEndDate is not None:
      oprot.writeFieldBegin('batchEndDate', TType.STRING, 5)
      oprot.writeString(self.batchEndDate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.groupBy)
    value = (value * 31) ^ hash(self.inputAvroSchema)
    value = (value * 31) ^ hash(self.selectedAvroSchema)
    value = (value * 31) ^ hash(self.keyAvroSchema)
    value = (value * 31) ^ hash(self.batchEndDate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
