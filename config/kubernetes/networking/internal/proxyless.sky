# DO NOT EDIT: http://go/vendor-skycfg
ENVOY_CONFIG_SRV_PB = proto.package("stripe_internal.envoy_config_srv")


def proxyless_service_registration(ctx, consul_agent_services, k8s_workload_name):
    """
    This function converts the proxyful service registrations to proxyless service registrations
    based on the service config.

    Args:
        ctx: The context object.
        consul_agent_services: The list of Consul agent services.
        k8s_workload_name: The name of the Kubernetes workload.

    Returns:
         proxyless registrations.
    """
    networking = ctx.vars.get("service.config.networking")
    if networking == None:
        return []
    mesh_service_configs = networking.mesh_services
    if mesh_service_configs == None:
        return []
    proxyless_registrations = []
    for consul_service in consul_agent_services:
        configured = _configure_proxyless_registration(ctx, consul_service, mesh_service_configs, consul_agent_services, k8s_workload_name)
        if configured != None:
            proxyless_registrations.append(configured)
    _sanity_check_proxyless_registrations(proxyless_registrations)
    return proxyless_registrations

def _enable_proxyless_registration(proxyless_registration_config, k8s_workload_name):
    if proxyless_registration_config == None:
        return False
    if proxyless_registration_config.type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED:
        fail("Invalid service config: proxyless_registration must have non-UNSPECIFIED type")
    filter = proxyless_registration_config.filter
    ## No filters to apply, defaults to enable
    if filter == None:
        return True
    if len(filter.k8s_workloads) == 0:
        return True
    k8s_workload_name = _k8s_workload_name_no_color(k8s_workload_name)
    for workload in filter.k8s_workloads:
        if k8s_workload_name == workload:
            return True
    return False

def _k8s_workload_name_no_color(k8s_workload_name):
    k8s_workload_name = k8s_workload_name.removesuffix("-blue")
    return k8s_workload_name.removesuffix("-green")

def _configure_proxyless_registration(ctx, consul_service, mesh_service_configs, consul_agent_services, k8s_workload_name):
    all_consul_service_names = [consul_service["name"] for consul_service in consul_agent_services]
    name = consul_service["name"]
    if name not in mesh_service_configs:
        return None
    service_config = _get_service_config_by_env(ctx, mesh_service_configs[name])
    if service_config == None:
        return None
    proxyless_registration_config = service_config.proxyless_registration
    if not _enable_proxyless_registration(proxyless_registration_config, k8s_workload_name):
        return None
    if _proxyless_name(consul_service) in all_consul_service_names:
        fail("Invalid service config: found duplicate proxyless registration for mesh service: " + name)
    configured = _convert_to_grpc_proxyless_registration(ctx, consul_service, proxyless_registration_config)
    return configured

def _proxyless_port(proxyless_reg):
    port = proxyless_reg.port
    if port == 0:
        port = 13333
    return port

def _proxyless_tags(consul_service, proxyless_reg_config):
    proxyfull_tags = consul_service["tags"]
    if proxyless_reg_config.exclude_from_service_mesh:
        proxyless_tags = [tag for tag in proxyfull_tags if tag != "grpc"]
        proxyless_tags.append("exclude_from_service_mesh")
    else:
        proxyless_tags = proxyfull_tags + ["envoy_direct"]
    return proxyless_tags

def _proxyless_name(consul_service):
    return consul_service["name"] + "-proxyless"

def _proxyless_checks(consul_service, port):
    checks = []
    for check in consul_service["checks"]:
        if "grpc" not in check:
            checks.append(check)
        else:
            copy = dict(check)
            copy["grpc"] = dict(check["grpc"])
            copy["grpc"]["port"] = port
            copy["grpc_use_tls"] = True
            copy["tls_skip_verify"] = True
            checks.append(copy)
    return checks

def _get_service_config_by_env(ctx, service_config):
    env = ctx.vars.get("stripe.environment")
    if env == "qa":
        return service_config.qa
    if env == "preprod":
        return service_config.preprod
    return service_config.prod

def _convert_to_grpc_proxyless_registration(ctx, consul_service, proxyless_reg_config):
    proxyless_registration = dict(consul_service)
    port = _proxyless_port(proxyless_reg_config)
    tags = _proxyless_tags(consul_service, proxyless_reg_config)
    name = _proxyless_name(consul_service)
    checks = _proxyless_checks(consul_service, port)

    proxyless_registration["name"] = name
    proxyless_registration["port"] = port
    proxyless_registration["tags"] = tags
    proxyless_registration["checks"] = checks
    ## meta remains the same

    return proxyless_registration

def _sanity_check_proxyless_registrations(proxyless_registrations):
    ## make sure no duplicate ports
    ports = list()
    for proxyless_reg in proxyless_registrations:
        port = proxyless_reg["port"]
        if port in ports:
            fail("Invalid service config: found duplicate proxyless registration for port: " + str(port))
        ports.append(port)
