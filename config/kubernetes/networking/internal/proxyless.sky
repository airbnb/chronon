# DO NOT EDIT: http://go/vendor-skycfg
ENVOY_CONFIG_SRV_PB = proto.package("stripe_internal.envoy_config_srv")


def proxyless_mesh_service_name(ctx, consul_agent_services, k8s_workload_name):
    mesh_service_configs = _get_mesh_service_configs(ctx)
    if mesh_service_configs == None:
        return "unknown"

    # heuristically determine the mesh service name based on the first service that has a proxyless registration
    # this might not work for eventbus that has multiple services with proxyless registrations, i.e. eventbus-grpc and eventbus-cell-2
    # so we need to figure out a strategy to handle this case
    for consul_service in consul_agent_services:
        registration_type = _get_registration_type(ctx, consul_service, mesh_service_configs, k8s_workload_name)
        if registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_SEPARATE:
            return _proxyless_name(consul_service)
        elif registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_INPLACE:
            return consul_service["name"]
    return "unknown"

def augment_with_proxyless_registrations(ctx, consul_agent_services, k8s_workload_name):
    """
    This function converts the proxyful service registrations to proxyless service registrations
    based on the service config.

    Args:
        ctx: The context object.
        consul_agent_services: The list of Consul agent services.
        k8s_workload_name: The name of the Kubernetes workload.

    Returns:
         proxyless registrations.
    """
    mesh_service_configs = _get_mesh_service_configs(ctx)
    if mesh_service_configs == None:
        return consul_agent_services
    registrations = []
    proxyless_registrations = []
    for consul_service in consul_agent_services:
        registration_type = _get_registration_type(ctx, consul_service, mesh_service_configs, k8s_workload_name)
        if registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED:
            registrations.append(consul_service)
        elif registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_SEPARATE or registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC:
            registrations.append(consul_service)
            proxyless_registration = _configure_proxyless_registration_separate(ctx, consul_service, mesh_service_configs, consul_agent_services, k8s_workload_name)
            registrations.append(proxyless_registration)
            proxyless_registrations.append(proxyless_registration)
        elif registration_type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_INPLACE:
            proxyless_registration = _configure_proxyless_registration_inplace(ctx, consul_service, mesh_service_configs)
            registrations.append(proxyless_registration)
            proxyless_registrations.append(proxyless_registration)
    return registrations

def _get_mesh_service_configs(ctx):
    networking = ctx.vars.get("service.config.networking")
    if networking == None:
        return None
    return networking.mesh_services

def _get_registration_type(ctx, consul_service, mesh_service_configs, k8s_workload_name):
    name = consul_service["name"]
    if name not in mesh_service_configs:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED
    service_config = _get_service_config_by_env(ctx, mesh_service_configs[name])
    if service_config == None:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED

    proxyless_registration = service_config.proxyless_registration
    if proxyless_registration == None or proxyless_registration.type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED

    if proxyless_registration.type == ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_INPLACE:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_INPLACE

    filter = proxyless_registration.filter
    ## No filters to apply, defaults to enable
    if filter == None:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_SEPARATE
    if len(filter.k8s_workloads) == 0:
        return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_SEPARATE
    k8s_workload_name = _k8s_workload_name_no_color(k8s_workload_name)
    for workload in filter.k8s_workloads:
        if k8s_workload_name == workload:
            return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.GRPC_SEPARATE
    return ENVOY_CONFIG_SRV_PB.ProxylessRegistration.Type.UNSPECIFIED

def _k8s_workload_name_no_color(k8s_workload_name):
    k8s_workload_name = k8s_workload_name.removesuffix("-blue")
    return k8s_workload_name.removesuffix("-green")

def _get_registration_config(ctx, mesh_service_configs, consul_service):
    name = consul_service["name"]
    service_config = _get_service_config_by_env(ctx, mesh_service_configs[name])
    return service_config.proxyless_registration

def _configure_proxyless_registration_separate(ctx, consul_service, mesh_service_configs, consul_agent_services, k8s_workload_name):
    all_consul_service_names = [consul_service["name"] for consul_service in consul_agent_services]
    if _proxyless_name(consul_service) in all_consul_service_names:
        fail("Invalid service config: found duplicate proxyless registration for mesh service: " + consul_service["name"])
    registration_config = _get_registration_config(ctx, mesh_service_configs, consul_service)
    return _convert_to_grpc_proxyless_registration_separate(consul_service, registration_config)

def _configure_proxyless_registration_inplace(ctx, consul_service, mesh_service_configs):
    registration_config = _get_registration_config(ctx, mesh_service_configs, consul_service)
    return _convert_to_grpc_proxyless_registration_inplace(consul_service, registration_config)

def _proxyless_port(proxyless_reg):
    port = proxyless_reg.port
    if port == 0:
        port = 13333
    return port

def _proxyless_tags(consul_service, proxyless_reg_config):
    proxyfull_tags = consul_service["tags"]
    if proxyless_reg_config.exclude_from_service_mesh:
        proxyless_tags = [tag for tag in proxyfull_tags if tag != "grpc"]
        proxyless_tags.append("exclude_from_service_mesh")
    else:
        proxyless_tags = proxyfull_tags + ["envoy_direct"]
    return proxyless_tags

def _proxyless_name(consul_service):
    return consul_service["name"] + "-proxyless"

def _proxyless_checks(consul_service, port):
    checks = []
    for check in consul_service["checks"]:
        if "grpc" not in check:
            # horizon services use HTTP for service health check, same applies to proxyless endpoints.
            checks.append(check)
        else:
            # otherwise, convert to gRPC mTLS health check
            copy = dict(check)
            copy["grpc"] = dict(check["grpc"])
            copy["grpc"]["port"] = port
            copy["grpc_use_tls"] = True
            copy["tls_skip_verify"] = True
            checks.append(copy)
    return checks

def _get_service_config_by_env(ctx, service_config):
    env = ctx.vars.get("stripe.environment")
    if env == "qa":
        return service_config.qa
    if env == "preprod":
        return service_config.preprod
    return service_config.prod

def _convert_to_grpc_proxyless_registration_inplace(consul_service, proxyless_reg_config):
    proxyless_registration = dict(consul_service)
    port = _proxyless_port(proxyless_reg_config)
    checks = _proxyless_checks(consul_service, port)
    
    # copy the entire dictionary instead of mutating inplace
    # to avoid errors when inserting into a frozen hashtable.
    meta = dict(proxyless_registration["meta"])
    meta["proxyless"] = "true"

    proxyless_registration["port"] = port
    proxyless_registration["checks"] = checks
    proxyless_registration["meta"] = meta
    return proxyless_registration

def _convert_to_grpc_proxyless_registration_separate(consul_service, proxyless_reg_config):
    proxyless_registration = dict(consul_service)
    port = _proxyless_port(proxyless_reg_config)
    tags = _proxyless_tags(consul_service, proxyless_reg_config)
    name = _proxyless_name(consul_service)
    checks = _proxyless_checks(consul_service, port)

    proxyless_registration["name"] = name
    proxyless_registration["port"] = port
    proxyless_registration["tags"] = tags
    proxyless_registration["checks"] = checks
    ## meta remains the same

    return proxyless_registration
