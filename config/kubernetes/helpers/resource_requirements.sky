# DO NOT EDIT: http://go/vendor-skycfg
load("config/kubernetes/core/container.sky", "resource_requirements")
load("config/kubernetes/helpers/warning.sky", "warn")
load("config/kubernetes/helpers/context.sky", "get_service_deploy_config", "get_env")
load("config/kubernetes/helpers/quantities.sky", "mebibytes", "millicores")

def ResourceRequirements(ctx, all = None, qa = None, prod = None, preprod = None):
    if all == None and qa == None and prod == None and preprod == None:
        fail("At least one of all, qa, preprod, or prod must be specified for ResourceRequirements")

    # If they specify an all, generate versions of the same resources for all envs and add it to the struct
    if all != None:
        return _buildMatchingResourceLimit(ctx, all)

    # Validate that if any of these values are passed, they are valid
    _validResourceLimit(qa)
    _validResourceLimit(prod)
    _validResourceLimit(preprod)

    # Special case - if the user specifies prod, but not preprod, then we use prod for preprod
    # this follows the convention that PreProd should be as similar to Prod as possible.
    preprod_val = _buildResourceRequirementFromSpec(ctx, prod)
    if preprod != None:
        preprod_val = _buildResourceRequirementFromSpec(ctx, preprod)

    return struct(
        qa = _buildResourceRequirementFromSpec(ctx, qa),
        preprod = preprod_val,
        prod = _buildResourceRequirementFromSpec(ctx, prod),
    )

def _qa_resource_requirements(ctx, val = None):
    if val == None:
        fail("Must pass a value to set to for the QA resource requirements")

    return ResourceRequirements(
        ctx,
        qa = val,
    )

def _preprod_resource_requirements(ctx, val = None):
    if val == None:
        fail("Must pass a value to set to for the PreProd resource requirements")

    return ResourceRequirements(
        ctx,
        preprod = val,
    )

def _prod_resource_requirements(ctx, val = None):
    if val == None:
        fail("Must pass a value to set to for the Prod resource requirements")

    return ResourceRequirements(
        ctx,
        prod = val,
    )

def ResourceRequirementSpec(cpu, memory, storage = None):
    return {
        "cpu": cpu,
        "memory": memory,
        "storage": storage,
    }

def _buildMatchingResourceLimit(ctx, spec):
        if spec == None:
            return None

        _validResourceLimit(spec)
        reqs = _buildResourceRequirementFromSpec(ctx, spec)
        return struct(
            qa = reqs,
            preprod = reqs,
            prod = reqs,
        )

def _buildResourceRequirementFromSpec(ctx, spec):
        if spec == None:
            return None

        # We are enforcing that requests = limits
        requests_and_limits = {
             "cpu": spec["cpu"],
             "memory": spec["memory"],
        }

        return resource_requirements(
            ctx,
            storage = spec.get("storage", None),
            requests = requests_and_limits,
            limits = requests_and_limits,
        )

def _validResourceLimit(resourceLimit):
    if resourceLimit == None:
        return

    if resourceLimit.get("cpu", None) == None:
        fail("cpu must be specified for ResourceLimit")
    if resourceLimit.get("memory", None) == None:
        fail("memory must be specified for ResourceLimit")

def attempt_to_get_pod_sizing_from_compute_config(ctx, compute_config):
    pod_sizing = _extract_sizing_from_compute_config(compute_config)
    if pod_sizing == None:
        return None

    cpu_millicores = pod_sizing[0]
    memory_mebibytes = pod_sizing[1]

    spec_val = ResourceRequirementSpec(
        cpu = millicores(ctx, cpu_millicores),
        memory = mebibytes(ctx, memory_mebibytes),
    )

    current_env = get_env(ctx)
    if current_env == "qa":
        return _qa_resource_requirements(ctx, val = spec_val)
    if current_env == "preprod":
        return _preprod_resource_requirements(ctx, val = spec_val)
    if current_env == "prod":
        return _prod_resource_requirements(ctx, val = spec_val)

    # this should never happen, fail if it does.
    fail("no mapping for environment={} in attempt_to_get_workload_sizing_from_ctx".format(current_env))

def _extract_sizing_from_compute_config(compute_config):
    if not compute_config:
        return None

    if type(compute_config) == "dict":
        return _extract_sizing_from_compute_config_dict(compute_config)

    return _extract_sizing_from_compute_config_struct(compute_config)

def _extract_sizing_from_compute_config_struct(compute_config):
    if not hasattr(compute_config, "resources"):
        return None
    if not hasattr(compute_config.resources, "pod_requirements"):
        return None
    if compute_config.resources.pod_requirements == None:
        return None

    return compute_config.resources.pod_requirements.cpu_millicores, compute_config.resources.pod_requirements.memory_mebibytes

def _extract_sizing_from_compute_config_dict(compute_config):
    pod_reqs = compute_config.get("resources", {}).get("pod_requirements", {})

    if pod_reqs == None:
        return None

    cpu = pod_reqs.get("cpu_millicores", None)
    mem = pod_reqs.get("memory_mebibytes", None)

    return int(cpu), int(mem)