# DO NOT EDIT: http://go/vendor-skycfg
### Apiregistration v1
def APIService(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "apiregistration.k8s.io/v1", kind = "APIService", marshal = True, **kwargs)

def APIServiceSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ServiceReference(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Apps v1

def DaemonSet(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "apps/v1", kind = "DaemonSet", marshal = True, **kwargs)

def DaemonSetSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def DaemonSetUpdateStrategy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Deployment(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "apps/v1", kind = "Deployment", marshal = True, **kwargs)

def DeploymentSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def DeploymentStrategy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RollingUpdateDaemonSet(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RollingUpdateDeployment(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RollingUpdateStatefulSetStrategy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def StatefulSet(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "apps/v1", kind = "StatefulSet", marshal = True, **kwargs)

def StatefulSetSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def StatefulSetUpdateStrategy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Autoscaling V2

def CrossVersionObjectReference(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HorizontalPodAutoscaler(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "autoscaling/v2", kind = "HorizontalPodAutoscaler", marshal = True, **kwargs)

def HorizontalPodAutoscalerBehavior(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HorizontalPodAutoscalerSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HPAScalingPolicy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HPAScalingRules(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def MetricSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def MetricTarget(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ResourceMetricSource(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def VerticalPodAutoscaler(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "autoscaling.k8s.io/v1", kind = "VerticalPodAutoscaler", marshal = True, **kwargs)

def VerticalPodAutoscalerSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Batch v1

def Job(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "batch/v1", kind = "Job", marshal = True, **kwargs)

def JobSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def JobTemplateSpec(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have JobTemplateSpec v1.
    return _generic_kubernetes_yaml(ctx, **kwargs)

def CronJob(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have CronJob v1.
    return _generic_kubernetes_yaml(ctx, apiVersion = "batch/v1", kind = "CronJob", marshal = True, **kwargs)

def CronJobSpec(ctx, **kwargs):
    # TODO: deprecate _batch_beta1; the version of protos imported today aren't up to date
    # and don't have CronJobSpec v1.
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Core v1

def Affinity(ctx, podAntiAffinity):
    return {
        "podAntiAffinity": podAntiAffinity
    }

def Capabilities(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Container(ctx, **kwargs):
    if kwargs.get("resources", None) == None:
        fail("Container resources must be specified, either with real or None values for requests and limits")

    return _generic_kubernetes_yaml(ctx, **kwargs)

def ContainerPort(ctx, containerPort, hostPort, name):
    return {
        "containerPort": containerPort,
        "hostPort": hostPort,
        "name": name
    }

def EmptyDirVolumeSource(ctx, **kwargs):
    vol = {}

    for key, value in kwargs.items():
        vol[key] = value

    return vol


def EnvVar(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def EnvVarSource(ctx, fieldRef):
    return {
        "fieldRef": fieldRef,
    }

def ExecAction(ctx, command):
    return {
        "command": command
    }

def HTTPGetAction(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HTTPHeader(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)


def Handler(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HostPathVolumeSource(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Lifecycle(ctx, **kwargs):
    lifecycle = {}

    for key, value in kwargs.items():
        lifecycle[key] = value

    return lifecycle

def LifecycleHandler(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ObjectFieldSelector(ctx, fieldPath):
    return {
        "fieldPath": fieldPath,
    }


def PodAffinityTerm(ctx, **kwargs):
    for key, value in kwargs.items():
        # Get rid of None values.
        if value != None:
            kwargs[key] = value
        else:
            kwargs.pop(key)
    return _generic_kubernetes_yaml(ctx, **kwargs)


def PodAntiAffinity(ctx, preferredDuringSchedulingIgnoredDuringExecution = [], requiredDuringSchedulingIgnoredDuringExecution = []):
    return {
        "preferredDuringSchedulingIgnoredDuringExecution": preferredDuringSchedulingIgnoredDuringExecution,
        "requiredDuringSchedulingIgnoredDuringExecution": requiredDuringSchedulingIgnoredDuringExecution
    }

def PodSecurityContext(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def PodSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def PodTemplateSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Probe(ctx, **kwargs):
    # Remove nested handler that's required for protos
    if kwargs.get("handler", None) != None:
        for key, value in kwargs["handler"].items():
            kwargs[key] = value

        kwargs.pop("handler")

    return _generic_kubernetes_yaml(ctx, **kwargs)

def ProbeHandler(ctx, **kwargs):
    # Remove nested handler that's required for protos
    if kwargs.get("handler", None) != None:
        for key, value in kwargs["handler"].items():
            kwargs[key] = value

        kwargs.pop("handler")

    return _generic_kubernetes_yaml(ctx, **kwargs)

def ResourceRequirements(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def SecurityContext(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def SELinuxOptions(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Service(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion="v1", kind="Service", **kwargs)

def ServicePort(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ServiceSpec(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def TCPSocketAction(ctx, port):
    return {
        "port": port
    }


def Toleration(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def TopologySpreadConstraint(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Volume(ctx, **kwargs):
    # Remove nested volumeSource that's required for protos
    if kwargs.get("volumeSource", None) != None:
        for key, value in kwargs["volumeSource"].items():
            kwargs[key] = value

        kwargs.pop("volumeSource")

    return _generic_kubernetes_yaml(ctx, **kwargs)

def VolumeMount(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def VolumeSource(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def WeightedPodAffinityTerm(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Meta v1

def LabelSelector(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def LabelSelectorRequirement(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ObjectMeta(ctx, **kwargs):
    # Pop out an empty namespace which shows up as null. This is encountered when users set
    # namespace=None for clusterrole and clusterrolebindings.
    if "namespace" in kwargs and not kwargs["namespace"]:
        kwargs.pop("namespace")
    return _generic_kubernetes_yaml(ctx, **kwargs)

### AdmissionRegistration v1

def ValidatingWebhookConfiguration(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "admissionregistration.k8s.io/v1", kind = "ValidatingWebhookConfiguration", marshal = False, **kwargs)

def ValidatingWebhook(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def MutatingWebhookConfiguration(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion = "admissionregistration.k8s.io/v1", kind = "MutatingWebhookConfiguration", marshal = False, **kwargs)

def MutatingWebhook(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def WebhookClientConfig(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RuleWithOperations(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Rule(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### RBAC v1

def Role(ctx, **kwargs):
    if "namespace" in kwargs and not kwargs["namespace"]:
        kwargs.pop("namespace")
    return _generic_kubernetes_yaml(ctx, apiVersion="rbac.authorization.k8s.io/v1", kind="Role", **kwargs)

def RoleRef(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RoleBinding(ctx, **kwargs):
    if "namespace" in kwargs and not kwargs["namespace"]:
        kwargs.pop("namespace")
    return _generic_kubernetes_yaml(ctx, apiVersion="rbac.authorization.k8s.io/v1", kind="RoleBinding", **kwargs)

def ClusterRole(ctx, **kwargs):
    if "namespace" in kwargs and not kwargs["namespace"]:
        kwargs.pop("namespace")
    return _generic_kubernetes_yaml(ctx, apiVersion="rbac.authorization.k8s.io/v1", kind="ClusterRole", **kwargs)

def AggregationRule(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def ClusterRoleBinding(ctx, **kwargs):
    if "namespace" in kwargs and not kwargs["namespace"]:
        kwargs.pop("namespace")
    return _generic_kubernetes_yaml(ctx, apiVersion="rbac.authorization.k8s.io/v1", kind="ClusterRoleBinding", **kwargs)

def PolicyRule(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def Subject(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

### Node v1beta1

def RuntimeClass(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion="node.k8s.io/v1beta1", kind="RuntimeClass", **kwargs)

def Overhead(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion="node.k8s.io/v1beta1", kind="Overhead", **kwargs)

### Policy v1beta1

def IDRange(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def PodSecurityPolicy(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, apiVersion="policy/v1beta1", kind="PodSecurityPolicy", **kwargs)

def PodSecurityPolicySpec(ctx, **kwargs):
    if kwargs.get("hostPorts") != None:
        if kwargs["hostPorts"] == []:
            kwargs.pop("hostPorts")
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RunAsUserStrategyOptions(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def RunAsGroupStrategyOptions(ctx, **kwargs):

    return _generic_kubernetes_yaml(ctx, **kwargs)

def SupplementalGroupsStrategyOptions(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def FSGroupStrategyOptions(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def SELinuxStrategyOptions(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def AllowedHostPath(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

def HostPortRange(ctx, **kwargs):
    return _generic_kubernetes_yaml(ctx, **kwargs)

## Util

def IntOrString(ctx, intVal = None, strVal = None):
    if intVal != None:
        return intVal
    return strVal

def Quantity(ctx, string):
    return string


def _generic_kubernetes_yaml(ctx, apiVersion = None, kind = None, marshal = False, **kwargs):
    tmp = {}

    if apiVersion:
        tmp["apiVersion"] = apiVersion

    if kind:
        tmp["kind"] = kind

    for key, value in kwargs.items():
        tmp[key] = value

    if marshal:
        return yaml.marshal(tmp)
    else:
        return tmp
