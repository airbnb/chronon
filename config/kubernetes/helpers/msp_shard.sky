# DO NOT EDIT: http://go/vendor-skycfg
"""
Plugins for annotating which shard a pod will be deployed to.
"""

load("config/kubernetes/core/generic.sky", "is_dedicated_msp", "is_shared_msp")
load("config/kubernetes/helpers/context.sky", "get_target_shard", "get_env", "get_cluster")
load("config/kubernetes/plugins/compose.sky", "compose_plugins")
load("config/kubernetes/plugins/conditional.sky", "conditional_plugin")
load("config/kubernetes/plugins/types.sky", "any_resource_plugin")

# TODO(dfradette): remove this annotation once Amp has been changed to use `stripe.io/msp-shard`
MSP_CLUSTER_ANNOTATION = "stripe.io/msp-cluster"

MSP_SHARD_ANNOTATION = "stripe.io/msp-shard"

ACCOUNT_NAME_TO_ID = {
    "mainland": "030465607062",
    "mainland2": "108124432883",
    "msp-shared-all-pink": "213343938293",
}

SHARD_TYPE = struct(
    TEST="test",
    SHARED_MSP="shared_msp",
    DEDICATED_MSP="dedicated_msp",
    CANARY="canary",
)

SHARD_STATE = struct(
    PROVISIONING="PROVISIONING",
    RELEASE_CANDIDATE="RELEASE_CANDIDATE",
    GA="GA",
    DECOMMISSIONING="DECOMMISSIONING",
)

BINPACKING_STATE = struct(
    ENABLED="ENABLED",
    DISABLED="DISABLED",
)

def _shard(name, *, shared_msp=True, cron=False, account="mainland", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.GA, binpacking_state=BINPACKING_STATE.ENABLED):
    return struct(name=name, shared_msp=shared_msp, cron=cron, account=account, shard_type=shard_type, shard_state=shard_state, binpacking_state=binpacking_state)

ENV_CLUSTER_SHARDS = {
    "qa": {
        "bom": [
            _shard("kubemaster", cron=True),
        ],
        "cmh": [
            _shard("kubemaster", cron=True),
            _shard("kubeapiaa", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.GA),
        ],
        "east": [
            _shard("kubemaster", cron=True),
        ],
        "northwest": [
            _shard("kubemaster", shared_msp=False, cron=True, shard_type=SHARD_TYPE.DEDICATED_MSP, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("kubeapiaa"),
            _shard("kubeapibb"),
            _shard("kubeapicc"),
            _shard("kubeapidd", cron=True),
            _shard("kubeapitest", cron=True, shard_type=SHARD_TYPE.CANARY),
            _shard("msppink", account="msp-shared-all-pink", shard_type=SHARD_TYPE.TEST, shard_state=SHARD_STATE.RELEASE_CANDIDATE),
            _shard("mspyellow", account="northwest.qa.1.msp", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.RELEASE_CANDIDATE),
            _shard("mspaa", account="northwest.qa.1.msp", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.PROVISIONING),
        ],
    },
    "preprod": {
        "cmh": [
            _shard("kubemaster", cron=True),
            _shard("mspteal", account="cmh.preprod.1.msp", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.RELEASE_CANDIDATE),
        ]
    },
    "prod": {
        "bom": [
            _shard("kubemaster", cron=True, binpacking_state=BINPACKING_STATE.DISABLED),
        ],
        "cmh": [
            _shard("kubemaster", cron=True, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("kubeapiaa", shard_type=SHARD_TYPE.SHARED_MSP, binpacking_state=BINPACKING_STATE.DISABLED, shard_state=SHARD_STATE.GA),
        ],
        "east": [
            _shard("kubemaster", cron=True, binpacking_state=BINPACKING_STATE.DISABLED),
        ],
        "northwest": [
            _shard("kubemaster", shared_msp=False, cron=True, shard_type=SHARD_TYPE.DEDICATED_MSP, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("kubeapiaa"),
            _shard("kubeapibb"),
            _shard("kubeapicc"),
            _shard("kubeapidd", cron=True, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("kubeapiee", binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("kubeapitest", cron=True, shard_type=SHARD_TYPE.CANARY),
            _shard("mspruby", account="northwest.prod.1.msp", shard_type=SHARD_TYPE.SHARED_MSP, shard_state=SHARD_STATE.RELEASE_CANDIDATE),
        ],
    },
}


# Fake shards map to be used in tests. This allows us to decouple test cases from real shards
MOCK_SHARDS_MAP = {
    "qa": {
        "northwest": [
            _shard("shard1", shared_msp=False, cron=True, shard_type=SHARD_TYPE.DEDICATED_MSP, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("shard2"),
            _shard("shard3", cron=True, shard_type=SHARD_TYPE.CANARY),
            _shard("shard4", account="mainland2", shard_type=SHARD_TYPE.TEST, binpacking_state=BINPACKING_STATE.DISABLED),
            _shard("shard5", account="mainland3", shard_state=SHARD_STATE.PROVISIONING),
        ],
    },
}


def all_available_shards(ctx, shared_msp=None, shard_states=None, shard_types=None, binpacking_states=None, _override_shards_map=None):
    """
    Returns all available shards based on the current Henson context.

    Args:
      ctx: The Henson context.
      shared_msp: If specified, only return shards that do (True) or don't (False) support Shared MSP.
      shard_states: If specified, only return shards that have one of the specified state.
      shard_types: If specified, only return shards that have one of the specified type.
      binpacking_states: If specified, only return shards that have one of the specified binpacking state.
      _override_shards_map: Only used for tests, overrides the default shard map to allow testing for custom shard combinations
    """
    clusters = ENV_CLUSTER_SHARDS.get(get_env(ctx), {})
    # Only used in tests to provide a custom list of shards
    if _override_shards_map != None:
        clusters = _override_shards_map.get(get_env(ctx), {})

    shards = clusters.get(get_cluster(ctx), [])
    if shared_msp != None:
        shards = [s for s in shards if s.shared_msp == shared_msp]
    if shard_states != None:
        shards = [s for s in shards if s.shard_state in shard_states]
    if shard_types != None:
        shards = [s for s in shards if s.shard_type in shard_types]
    if binpacking_states != None:
        shards = [s for s in shards if s.binpacking_state in binpacking_states]
    return [s.name for s in shards]


def all_canary_shards(ctx, _override_shards_map=None):
    """
    Returns all GA canary shards based on the current Henson context.
    """
    return all_available_shards(
        ctx=ctx,
        shard_states=SHARD_STATE.GA,
        shard_types=[SHARD_TYPE.CANARY],
        _override_shards_map=_override_shards_map,
    )

def all_ga_shards(ctx, shard_types=None, _override_shards_map=None):
    """
    Returns all GA shards based on the current Henson context.

    Args:
      ctx: The Henson context.
      shard_types: If specified, only return shards that have one of the specified type.
      _override_shards_map: Only used for tests, overrides the default shard map to allow testing for custom shard combinations
    """
    return all_available_shards(
        ctx=ctx,
        shard_states=SHARD_STATE.GA,
        shard_types=shard_types,
        _override_shards_map=_override_shards_map,
    )

def all_binpacking_enabled_shards(ctx, shared_msp=None, shard_states=None, shard_types=None, _override_shards_map=None):
    """
    Returns all shards that have binpacking enabled based on the current Henson context.

    Args:
      ctx: The Henson context.
      shared_msp: If specified, only return shards that do (True) or don't (False) support Shared MSP.
      shard_states: If specified, only return shards that have one of the specified state.
      shard_types: If specified, only return shards that have one of the specified type.
      _override_shards_map: Only used for tests, overrides the default shard map to allow testing for custom shard combinations
    """
    return all_available_shards(
        ctx=ctx,
        shared_msp=shared_msp,
        shard_states=shard_states,
        shard_types=shard_types,
        binpacking_states=[BINPACKING_STATE.ENABLED],
        _override_shards_map=_override_shards_map,
    )

def is_shard_binpacking_enabled(ctx, shard, _override_shards_map=None):
    """
    Returns True if the shard has binpacking enabled based on the current Henson context.

    Args:
      ctx: The Henson context.
      shard: The name of the MSP shard.
    """
    clusters = ENV_CLUSTER_SHARDS.get(get_env(ctx), {})
    # Only used in tests to provide a custom list of shards
    if _override_shards_map != None:
        clusters = _override_shards_map.get(get_env(ctx), {})
    shards = clusters.get(get_cluster(ctx), [])
    for s in shards:
        if s.name == shard:
            return s.binpacking_state == BINPACKING_STATE.ENABLED
    # Return False if the shard is not found
    return False

def account_for_shard(ctx, shard):
    """
    Returns the AWS account that the shard is running in.
    Args:
      ctx: The Henson context.
      shard: The name of the MSP shard.
    """
    clusters = ENV_CLUSTER_SHARDS.get(get_env(ctx), {})
    shards = clusters.get(get_cluster(ctx), [])
    for s in shards:
        if s.name == shard:
            return s.account

    fail("Shard not found: {}".format(shard))


def all_available_shards_with_cron(ctx):
    """
    Returns all available shards based on the current Henson context in which cron is supported.
    Args:
      ctx: The Henson context.
    """
    clusters = ENV_CLUSTER_SHARDS.get(get_env(ctx), {})
    shards = clusters.get(get_cluster(ctx), [])
    return [s.name for s in shards if s.cron == True]

def msp_shard(shard):
    """
    Specify the MSP shard that the pod will be deployed to. Will error if the specified
    shard is not supported in the given context.
    Args:
        shard: The name of the MSP shard.
    """
    return any_resource_plugin(_set_msp_shard, shard = shard)

def _set_msp_shard(ctx, plugin, resource_def):
    shard = getattr(plugin, "shard")

    if shard not in all_available_shards(ctx):
        fail(
            "`{shard}` is not available in {env}-{cluster}".format(
            shard = shard,
            env = get_env(ctx),
            cluster = get_cluster(ctx),
        ))

    resource_def["metadata"]["annotations"].update(
            _shard_annotations(shard),
    )

def prefer_msp_shard(name = "kubeapiaa"):
  """
  Selects the shard if it's available within the current Henson context. If you are not
  on Orchestration, this probably isn't the plugin you are looking for!
  Args:
    name: The name of the MSP shard. Defaults to 'kubeapiaa'.
  """
  return any_resource_plugin(_prefer_msp_shard, preferred = name)

def _prefer_msp_shard(ctx, plugin, resource_def):
    preferred = getattr(plugin, "preferred")
    available_shards = all_available_shards(ctx)

    shard = "kubemaster"
    if preferred in available_shards:
        shard = preferred

    resource_def["metadata"]["annotations"].update(
        _shard_annotations(shard)
    )

def autoset_shard():
    """
    Returns a plugin that will automatically set the MSP
    target resource's shard to an appropriate selection.
        IMPORTANT: Shared MSP deployments of Horizon
    WILL NOT BE PROPERLY IDENTIFIED AS SHARED MSP via is_shared_msp
    due to a bug where Horizon sets their deployment context for
    Shared MSP deploys to shared_msp=False.
    Use autoset_shard_shared_msp instead in this case.
    """
    return compose_plugins(
        conditional_plugin(
            condition=is_shared_msp,
            plugin=autoset_shard_shared_msp(),
        ),
        conditional_plugin(
            condition=is_dedicated_msp,
            # legacy dedicated MSP services are fixed to run on kubemaster
            # for the time being
            plugin=msp_shard("kubemaster"),
        ),
    )

def autoset_shard_shared_msp():
    """
    Returns a plugin which will automatically set the MSP
    target resource's shard based on Henson context in
    Shared MSP only.
    This should ONLY be called if we are already known to be
    running in Shared MSP. Otherwise, utilize the
    autoset_shard() plugin which conditionally checks the
    Shared vs Dedicated state in the resource context.
    """
    return any_resource_plugin(_shard_from_henson)


def _shard_from_henson(ctx, plugin, resource_def):
    """
    Set the MSP target resource's shard to the shard provided by henson. Henson
    will factor in the deployment's cluster and env, load balancing
    considerations, as well as any explicit user overwrites to provide
    a shard that makes sense.
    """
    shard = get_target_shard(ctx)
    resource_def["metadata"]["annotations"].update(
        _shard_annotations(shard)
    )


def _shard_annotations(shard):
    return {
        MSP_CLUSTER_ANNOTATION: shard,
        MSP_SHARD_ANNOTATION: shard,
    }


def get_account_for_shard(ctx, shard):
    local_shards = ENV_CLUSTER_SHARDS.get(get_env(ctx), {}).get(get_cluster(ctx), [])
    for s in local_shards:
        if s.name == shard:
            return s.account
    return None


def get_account_id(ctx, account_name):
    return ACCOUNT_NAME_TO_ID.get(account_name)


def maybe_enable_security_group_policy(ctx, shard_name):
    """
    Enable Security Group Policy if this shard uses the VPC CNI
    for non-binpacked mspworkers. This function is only needed for
    multi-shard services, since henson can't properly setup feature-flags
    for them.
    """
    new_ctx = struct(vars = dict(ctx.vars))

    local_shards = ENV_CLUSTER_SHARDS.get(get_env(ctx), {}).get(get_cluster(ctx), [])
    for s in local_shards:
        if s.name == shard_name:
            if s.account != "mainland":
                new_ctx.vars["msp.use_sgp"] = True
            break

    return new_ctx
