# DO NOT EDIT: http://go/vendor-skycfg
"""
Common functions shared between Ruby services and Ruby workflow workers
"""
load("config/kubernetes/networking/internal/config/override.sky", "NOT_PROVIDED")
load("config/kubernetes/networking/public/config.sky", "networking_config", "global_ratelimit")
load("config/kubernetes/service-config/compute.sky", "get_merged_compute_v2_config")

def ruby_canary_suffix(ctx, default="-canary"):
    """ Get the suffix to be used for canaries

    Args:
        ctx: The context object
        default: The default suffix to be used if not specified
    Returns:
        the suffix to be used for the canary Ruby process
    """

    # Has ComputeV2?
    compute_config = ctx.vars.get("service.config.compute_v2")

    if compute_config == None:
        return default

    compute_config = get_merged_compute_v2_config(ctx)

    ruby_process = compute_config["ruby_process"]

    # Try to read from the StringValue suffix field
    if (
        ruby_process != None and
        ruby_process["canary_config"] != None and
        ruby_process["canary_config"]["suffix"] != None
    ):
        return str(ruby_process["canary_config"]["suffix"])

    return default

def get_networking_config(_, platform_options):
    """ Get the networking config for Ruby services

    Args:
        _: The context object (not currently used)
        platform_options: PlatformOptions protobuf message
    Returns:
        An array of plugins for configuring networking
    """
    global_ratelimit_val = NOT_PROVIDED
    egress_proxy_tier = NOT_PROVIDED
    enable_cross_domain_services = NOT_PROVIDED

    # handle enable_envoy_global_ratelimit
    # The trick here is that if not present, as a protobuf bool
    # enable_envoy_global_ratelimit defaults to False;
    # check for presence, then verify that it is actually True
    has_global_ratelimit = "enable_envoy_global_ratelimit" in platform_options and platform_options["enable_envoy_global_ratelimit"]

    if has_global_ratelimit:
        global_ratelimit_val = global_ratelimit(enable=True)

    # handle egress_proxy_tier
    if "egress_proxy_tier" in platform_options and platform_options["egress_proxy_tier"] != None:
        egress_proxy_tier = platform_options["egress_proxy_tier"]

    # handle enable_cross_domain_services
    if "enable_cross_domain_services" in platform_options and platform_options["enable_cross_domain_services"] != None:
        enable_cross_domain_services = platform_options["enable_cross_domain_services"]

    plugins = []
    if global_ratelimit_val != NOT_PROVIDED or egress_proxy_tier != NOT_PROVIDED or enable_cross_domain_services != NOT_PROVIDED:
        plugins.append(
            networking_config(
                global_ratelimit = global_ratelimit_val,
                egress_proxy_tier = egress_proxy_tier,
                enable_cross_domain_services = enable_cross_domain_services,
            )
        )

    return plugins
